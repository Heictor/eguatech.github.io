{"documents": [{"body": "Welcome to Rocket!  This is the official guide for Rocket v0.4. It is designed to serve as a starting point to writing web applications with Rocket and Rust. The guide is also designed to be a reference for experienced Rocket developers. This guide is conversational in tone. For purely technical documentation with examples, see the API documentation.  The guide is split into several sections, each with a focus on a different aspect of Rocket. The sections are:  Introduction: introduces Rocket and its philosophy.  Quickstart: presents the minimal steps necessary to   run your first Rocket application.  Getting Started: a gentle introduction to getting  your first Rocket application running.  Overview: describes the core concepts of Rocket.  Requests: discusses handling requests: control-flow,  parsing, and validating.  Responses: discusses generating responses.  State: how to manage state in a Rocket application.  Fairings: provides an overview of Rocket's structured  middleware.  Testing: how to unit and integration test a Rocket  application.  Configuration: how to configure a Rocket application.  Pastebin: a tutorial on how to create a pastebin with  Rocket.  Conclusion: concludes the guide and discusses next steps  for learning.", "title": "The Rocket Programming Guide", "breadcrumb": "The Rocket Programming Guide", "anchor": "#the-rocket-programming-guide", "id": "the-rocket-programming-guide#the-rocket-programming-guide"}, {"body": "The official community support channels are the #rocket IRC channel on the Mozilla IRC Server at irc.mozilla.org and the bridged Rocket room on Matrix. If you're not familiar with IRC, we recommend chatting through Matrix via Riot or via the Kiwi web IRC client. You can learn more about IRC via Mozilla's Getting Started with IRC guide.", "title": "Getting Help", "breadcrumb": "The Rocket Programming Guide > Getting Help", "anchor": "#getting-help", "id": "the-rocket-programming-guide#getting-help"}, {"body": "Rocket is a web framework for Rust. If you'd like, you can think of Rocket as being a more flexible, friendly medley of Rails, Flask, Bottle, and Yesod. We prefer to think of Rocket as something new. Rocket aims to be fast, easy, and flexible while offering guaranteed safety and security where it can. Importantly, Rocket also aims to be fun, and it accomplishes this by ensuring that you write as little code as needed to accomplish your task.  This guide introduces you to the core, intermediate, and advanced concepts of Rocket. After reading this guide, you should find yourself being very productive with Rocket.", "title": "Introduction", "breadcrumb": "Introduction", "anchor": "#introduction", "id": "introduction#introduction"}, {"body": "Readers are assumed to have a good grasp of the Rust programming language. Readers new to Rust are encouraged to read the Rust Book. This guide also assumes a basic understanding of web application fundamentals, such as routing and HTTP. Mozilla provides a good overview of these concepts in their MDN web docs.", "title": "Audience", "breadcrumb": "Introduction > Audience", "anchor": "#audience", "id": "introduction#audience"}, {"body": "Rocket's design is centered around three core philosophies:  Security, correctness, and developer experience are paramount.  The path of least resistance should lead you to the most secure, correct web application, though security and correctness should not come at the cost of a degraded developer experience. Rocket is easy to use while taking great measures to ensure that your application is secure and correct without cognitive overhead.  All request handling information should be typed and self-contained.  Because the web and HTTP are themselves untyped (or stringly typed, as some call it), this means that something or someone has to convert strings to native types. Rocket does this for you with zero programming overhead. What's more, Rocket's request handling is self-contained with zero global state: handlers are regular functions with regular arguments.  Decisions should not be forced.  Templates, serialization, sessions, and just about everything else are all pluggable, optional components. While Rocket has official support and libraries for each of these, they are completely optional and swappable.  These three ideas dictate Rocket's interface, and you will find all of them embedded in Rocket's core features.", "title": "Foreword", "breadcrumb": "Introduction > Foreword", "anchor": "#foreword", "id": "introduction#foreword"}, {"body": "Before you can start writing a Rocket application, you'll need a nightly version of Rust installed. We recommend you use rustup to install or configure such a version. If you don't have Rust installed and would like extra guidance doing so, see the getting started section.", "title": "Quickstart", "breadcrumb": "Quickstart", "anchor": "#quickstart", "id": "quickstart#quickstart"}, {"body": "The absolute fastest way to start experimenting with Rocket is to clone the Rocket repository and run the included examples in the examples/ directory. For instance, the following set of commands runs the hello_world example:  There are numerous examples in the examples/ directory. They can all be run with cargo run.  ! note  The examples' Cargo.toml files will point to the locally cloned rocket   libraries. When copying the examples for your own use, you should modify the   Cargo.toml files as explained in the Getting Started guide.", "title": "Running Examples", "breadcrumb": "Quickstart > Running Examples", "anchor": "#running-examples", "id": "quickstart#running-examples"}, {"body": "Let's create and run our first Rocket application. We'll ensure we have a compatible version of Rust, create a new Cargo project that depends on Rocket, and then run the application.", "title": "Getting Started", "breadcrumb": "Getting Started", "anchor": "#getting-started", "id": "getting-started#getting-started"}, {"body": "Rocket makes abundant use of Rust's syntax extensions and other advanced, unstable features. Because of this, we'll need to use a nightly version of Rust. If you already have a working installation of the latest Rust nightly, feel free to skip to the next section.  To install a nightly version of Rust, we recommend using rustup. Install rustup by following the instructions on its website. Once rustup is installed, configure Rust nightly as your default toolchain by running the command:  If you prefer, once we setup a project directory in the following section, you can use per-directory overrides to use the nightly version only for your Rocket project by running the following command in the directory:  ! warning: Rocket requires the latest version of Rust nightly.  If your Rocket application suddenly stops building, ensure you're using the   latest version of Rust nightly and Rocket by updating your toolchain and   dependencies with:  rustup update && cargo update", "title": "Installing Rust", "breadcrumb": "Getting Started > Installing Rust", "anchor": "#installing-rust", "id": "getting-started#installing-rust"}, {"body": "Let's write our first Rocket application! Start by creating a new binary-based Cargo project and changing into the new directory:  Now, add Rocket as a dependency in your Cargo.toml:  Modify src/main.rs so that it contains the code for the Rocket Hello, world! program, reproduced below:  We won't explain exactly what the program does now; we leave that for the rest of the guide. In short, it creates an index route, mounts the route at the / path, and launches the application. Compile and run the program with cargo run. You should see the following:  Visit http://localhost:8000 to see your first Rocket application in action!  ! tip: Don't like colors or emoji?  You can disable colors and emoji by setting the ROCKET_CLI_COLORS   environment variable to 0 or off when running a Rocket binary:  ROCKET_CLI_COLORS=off cargo run", "title": "Hello, world!", "breadcrumb": "Getting Started > Hello, world!", "anchor": "#hello-world", "id": "getting-started#hello-world"}, {"body": "Rocket provides primitives to build web servers and applications with Rust: Rocket provides routing, pre-processing of requests, and post-processing of responses; the rest is up to you. Your application code instructs Rocket on what to pre-process and post-process and fills the gaps between pre-processing and post-processing.", "title": "Overview", "breadcrumb": "Overview", "anchor": "#overview", "id": "overview#overview"}, {"body": "Rocket's main task is to listen for incoming web requests, dispatch the request to the application code, and return a response to the client. We call the process that goes from request to response the \"lifecycle\". We summarize the lifecycle as the following sequence of steps:  Routing  Rocket parses an incoming HTTP request into native structures that your  code operates on indirectly. Rocket determines which request handler to  invoke by matching against route attributes declared in your application.  Validation  Rocket validates the incoming request against types and guards present in  the matched route. If validation fails, Rocket forwards the request to  the next matching route or calls an error handler.  Processing  The request handler associated with the route is invoked with validated  arguments. This is the main business logic of an application. Processing  completes by returning a Response.  Response  The returned Response is processed. Rocket generates the appropriate HTTP  response and sends it to the client. This completes the lifecycle. Rocket  continues listening for requests, restarting the lifecycle for each  incoming request.  The remainder of this section details the routing phase as well as additional components needed for Rocket to begin dispatching requests to request handlers. The sections following describe the request and response phases as well as other components of Rocket.", "title": "Lifecycle", "breadcrumb": "Overview > Lifecycle", "anchor": "#lifecycle", "id": "overview#lifecycle"}, {"body": "Rocket applications are centered around routes and handlers. A route is a combination of:  A set of parameters to match an incoming request against.  A handler to process the request and return a response.  A handler is simply a function that takes an arbitrary number of arguments and returns any arbitrary type.  The parameters to match against include static paths, dynamic paths, path segments, forms, query strings, request format specifiers, and body data. Rocket uses attributes, which look like function decorators in other languages, to make declaring routes easy. Routes are declared by annotating a function, the handler, with the set of parameters to match against. A complete route declaration looks like this:  This declares the world route to match against the static path \"/world\" on incoming GET requests. The world route is simple, but additional route parameters are necessary when building more interesting applications. The Requests section describes the available options for constructing routes.", "title": "Routing", "breadcrumb": "Overview > Routing", "anchor": "#routing", "id": "overview#routing"}, {"body": "Before Rocket can dispatch requests to a route, the route needs to be mounted:  The mount method takes as input:  A base path to namespace a list of routes under, here, \"/hello\".  A list of routes via the routes! macro: here, routes![world], with   multiple routes: routes![a, b, c].  This creates a new Rocket instance via the ignite function and mounts the world route to the \"/hello\" path, making Rocket aware of the route. GET requests to \"/hello/world\" will be directed to the world function.  ! note: In many cases, the base path will simply be \"/\".", "title": "Mounting", "breadcrumb": "Overview > Mounting", "anchor": "#mounting", "id": "overview#mounting"}, {"body": "When a route is declared inside a module other than the root, you may find yourself with unexpected errors when mounting:  This occurs because the routes! macro implicitly converts the route's name into the name of a structure generated by Rocket's code generation. The solution is to refer to the route using a namespaced path instead:", "title": "Namespacing", "breadcrumb": "Overview > Mounting > Namespacing", "anchor": "#namespacing", "id": "overview#namespacing"}, {"body": "Now that Rocket knows about the route, you can tell Rocket to start accepting requests via the launch method. The method starts up the server and waits for incoming requests. When a request arrives, Rocket finds the matching route and dispatches the request to the route's handler.  We typically call launch from the main function. Our complete Hello, world! application thus looks like:  Note the #![feature] line: this tells Rust that we're opting in to compiler features available in the nightly release channel. This line must be in the crate root, typically main.rs. We've also imported the rocket crate and all of its macros into our namespace via #[macro_use] extern crate rocket. Finally, we call the launch method in the main function.  Running the application, the console shows:  If we visit localhost:8000/hello/world, we see Hello, world!, exactly as we expected.  A version of this example's complete crate, ready to cargo run, can be found on GitHub. You can find dozens of other complete examples, spanning all of Rocket's features, in the GitHub examples directory.", "title": "Launching", "breadcrumb": "Overview > Launching", "anchor": "#launching", "id": "overview#launching"}, {"body": "Together, a route attribute and function signature specify what must be true about a request in order for the route's handler to be called. You've already seen an example of this in action:  This route indicates that it only matches against GET requests to the /world route. Rocket ensures that this is the case before handler is called. Of course, you can do much more than specify the method and path of a request. Among other things, you can ask Rocket to automatically validate:  The type of a dynamic path segment.  The type of several dynamic path segments.  The type of incoming body data.  The types of query strings, forms, and form values.  The expected incoming or outgoing format of a request.  Any arbitrary, user-defined security or validation policies.  The route attribute and function signature work in tandem to describe these validations. Rocket's code generation takes care of actually validating the properties. This section describes how to ask Rocket to validate against all of these properties and more.", "title": "Requests", "breadcrumb": "Requests", "anchor": "#requests", "id": "requests#requests"}, {"body": "A Rocket route attribute can be any one of get, put, post, delete, head, patch, or options, each corresponding to the HTTP method to match against. For example, the following attribute will match against POST requests to the root path:  The grammar for these attributes is defined formally in the rocket_codegen API docs.", "title": "Methods", "breadcrumb": "Requests > Methods", "anchor": "#methods", "id": "requests#methods"}, {"body": "Rocket handles HEAD requests automatically when there exists a GET route that would otherwise match. It does this by stripping the body from the response, if there is one. You can also specialize the handling of a HEAD request by declaring a route for it; Rocket won't interfere with HEAD requests your application explicitly handles.", "title": "HEAD Requests", "breadcrumb": "Requests > Methods > HEAD Requests", "anchor": "#head-requests", "id": "requests#head-requests"}, {"body": "Because HTML forms can only be directly submitted as GET or POST requests, Rocket reinterprets request methods under certain conditions. If a POST request contains a body of Content-Type: application/x-www-form-urlencoded and the form's first field has the name _method and a valid HTTP method name as its value (such as \"PUT\"), that field's value is used as the method for the incoming request.  This allows Rocket applications to submit non-POST forms. The todo example makes use of this feature to submit PUT and DELETE requests from a web form.", "title": "Reinterpreting", "breadcrumb": "Requests > Methods > Reinterpreting", "anchor": "#reinterpreting", "id": "requests#reinterpreting"}, {"body": "You can declare path segments as dynamic by using angle brackets around variable names in a route's path. For example, if we want to say Hello! to anything, not just the world, we can declare a route like so:  If we were to mount the path at the root (.mount(\"/\", routes![hello])), then any request to a path with two non-empty segments, where the first segment is hello, will be dispatched to the hello route. For example, if we were to visit /hello/John, the application would respond with Hello, John!.  Any number of dynamic path segments are allowed. A path segment can be of any type, including your own, as long as the type implements the FromParam trait. We call these types parameter guards. Rocket implements FromParam for many of the standard library types, as well as a few special Rocket types. For the full list of provided implementations, see the FromParam API docs. Here's a more complete route to illustrate varied usage:  ! note: Rocket types raw strings separately from decoded strings.  You may have noticed an unfamiliar RawStr type in the code example above.   This is a special type, provided by Rocket, that represents an unsanitized,   unvalidated, and undecoded raw string from an HTTP message. It exists to   separate validated string inputs, represented by types such as String,   &str, and Cow<str>, from unvalidated inputs, represented by &RawStr. It   also provides helpful methods to convert the unvalidated string into a   validated one.  Because &RawStr implements FromParam, it can be used as the type of a   dynamic segment, as in the example above, where the value refers to a   potentially undecoded string. By contrast, a String is guaranteed to be   decoded. Which you should use depends on whether you want direct but   potentially unsafe access to the string (&RawStr), or safe access to the   string at the cost of an allocation (String).", "title": "Dynamic Paths", "breadcrumb": "Requests > Dynamic Paths", "anchor": "#dynamic-paths", "id": "requests#dynamic-paths"}, {"body": "You can also match against multiple segments by using <param..> in a route path. The type of such parameters, known as segments guards, must implement FromSegments. A segments guard must be the final component of a path: any text after a segments guard will result in a compile-time error.  As an example, the following route matches against all paths that begin with /page/:  The path after /page/ will be available in the path parameter. The FromSegments implementation for PathBuf ensures that path cannot lead to path traversal attacks. With this, a safe and secure static file server can be implemented in 4 lines:  ! tip: Rocket makes it even easier to serve static files!  If you need to serve static files from your Rocket application, consider using   the StaticFiles custom handler from rocket_contrib, which makes it as   simple as:  rocket.mount(\"/public\", StaticFiles::from(\"/static\"))", "title": "Multiple Segments", "breadcrumb": "Requests > Dynamic Paths > Multiple Segments", "anchor": "#multiple-segments", "id": "requests#multiple-segments"}, {"body": "Let's take a closer look at the route attribute and signature pair from a previous example:  What if cool isn't a bool? Or, what if age isn't a u8? When a parameter type mismatch occurs, Rocket forwards the request to the next matching route, if there is any. This continues until a route doesn't forward the request or there are no remaining routes to try. When there are no remaining routes, a customizable 404 error is returned.  Routes are attempted in increasing rank order. Rocket chooses a default ranking from -6 to -1, detailed in the next section, but a route's rank can also be manually set with the rank attribute. To illustrate, consider the following routes:  Notice the rank parameters in user_int and user_str. If we run this application with the routes mounted at the root path, as is done in main above, requests to /user/<id> (such as /user/123, /user/Bob, and so on) will be routed as follows:  The user route matches first. If the string at the <id> position is an  unsigned integer, then the user handler is called. If it is not, then the  request is forwarded to the next matching route: user_int.  The user_int route matches next. If <id> is a signed integer,  user_int is called. Otherwise, the request is forwarded.  The user_str route matches last. Since <id> is a always string, the  route always matches. The user_str handler is called.  ! note: A route's rank appears in [brackets] during launch.  You'll also find a route's rank logged in brackets during application launch:   GET /user/<id> [3] (user_str).  Forwards can be caught by using a Result or Option type. For example, if the type of id in the user function was Result<usize, &RawStr>, then user would never forward. An Ok variant would indicate that <id> was a valid usize, while an Err would indicate that <id> was not a usize. The Err's value would contain the string that failed to parse as a usize.  ! tip: It's not just forwards that can be caught!  In general, when any guard fails for any reason, including parameter guards,   you can use an Option or Result type in its place to catch the failure.  By the way, if you were to omit the rank parameter in the user_str or user_int routes, Rocket would emit an error and abort launch, indicating that the routes collide, or can match against similar incoming requests. The rank parameter resolves this collision.", "title": "Forwarding", "breadcrumb": "Requests > Forwarding", "anchor": "#forwarding", "id": "requests#forwarding"}, {"body": "If a rank is not explicitly specified, Rocket assigns a default ranking. By default, routes with static paths and query strings have lower ranks (higher precedence) while routes with dynamic paths and without query strings have higher ranks (lower precedence). The table below describes the default ranking of a route given its properties.", "title": "Default Ranking", "breadcrumb": "Requests > Forwarding > Default Ranking", "anchor": "#default-ranking", "id": "requests#default-ranking"}, {"body": "Query segments can be declared static or dynamic in much the same way as path segments:  The hello route above matches any GET request to /hello that has at least one query key of name and a query segment of wave in any order, ignoring any extra query segments. The value of the name query parameter is used as the value of the name function argument. For instance, a request to /hello?wave&name=John would return Hello, John!. Other requests that would result in the same response include:  /hello?name=John&wave (reordered)  /hello?name=John&wave&id=123 (extra segments)  /hello?id=123&name=John&wave (reordered, extra segments)  /hello?name=Bob&name=John&wave (last value taken)  Any number of dynamic query segments are allowed. A query segment can be of any type, including your own, as long as the type implements the FromFormValue trait.", "title": "Query Strings", "breadcrumb": "Requests > Query Strings", "anchor": "#query-strings", "id": "requests#query-strings"}, {"body": "Query parameters are allowed to be missing. As long as a request's query string contains all of the static components of a route's query string, the request will be routed to that route. This allows for optional parameters, validating even when a parameter is missing.  To achieve this, use Option<T> as the parameter type. Whenever the query parameter is missing in a request, None will be provided as the value.  A route using Option<T> looks as follows:  Any GET request with a path of /hello and a wave query segment will be routed to this route. If a name=value query segment is present, the route returns the string \"Hi, value!\". If no name query segment is present, the route returns \"Hello!\".  Just like a parameter of type Option<T> will have the value None if the parameter is missing from a query, a parameter of type bool will have the value false if it is missing. The default value for a missing parameter can be customized for your own types that implement FromFormValue by implementing FromFormValue::default().", "title": "Optional Parameters", "breadcrumb": "Requests > Query Strings > Optional Parameters", "anchor": "#optional-parameters", "id": "requests#optional-parameters"}, {"body": "As with paths, you can also match against multiple segments in a query by using <param..>. The type of such parameters, known as query guards, must implement the FromQuery trait. Query guards must be the final component of a query: any text after a query parameter will result in a compile-time error.  A query guard validates all otherwise unmatched (by static or dynamic query parameters) query segments. While you can implement FromQuery yourself, most use cases will be handled by using the Form or LenientForm query guard. The Forms section explains using these types in detail. In short, these types allow you to use a structure with named fields to automatically validate query/form parameters:  For a request to /item?id=100&name=sandal&account=400, the item route above sets id to 100 and user to User { name: \"sandal\", account: 400 }. To catch forms that fail to validate, use a type of Option or Result:  For more query handling examples, see the query_params example.", "title": "Multiple Segments", "breadcrumb": "Requests > Query Strings > Multiple Segments", "anchor": "#multiple-segments", "id": "requests#multiple-segments"}, {"body": "Request guards are one of Rocket's most powerful instruments. As the name might imply, a request guard protects a handler from being called erroneously based on information contained in an incoming request. More specifically, a request guard is a type that represents an arbitrary validation policy. The validation policy is implemented through the FromRequest trait. Every type that implements FromRequest is a request guard.  Request guards appear as inputs to handlers. An arbitrary number of request guards can appear as arguments in a route handler. Rocket will automatically invoke the FromRequest implementation for request guards before calling the handler. Rocket only dispatches requests to a handler when all of its guards pass.  For instance, the following dummy handler makes use of three request guards, A, B, and C. An input can be identified as a request guard if it is not named in the route attribute.  Request guards always fire in left-to-right declaration order. In the example above, the order will be A followed by B followed by C. Failure is short-circuiting; if one guard fails, the remaining are not attempted. To learn more about request guards and implementing them, see the FromRequest documentation.", "title": "Request Guards", "breadcrumb": "Requests > Request Guards", "anchor": "#request-guards", "id": "requests#request-guards"}, {"body": "You can implement FromRequest for your own types. For instance, to protect a sensitive route from running unless an ApiKey is present in the request headers, you might create an ApiKey type that implements FromRequest and then use it as a request guard:  You might also implement FromRequest for an AdminUser type that authenticates an administrator using incoming cookies. Then, any handler with an AdminUser or ApiKey type in its argument list is assured to only be invoked if the appropriate conditions are met. Request guards centralize policies, resulting in a simpler, safer, and more secure applications.", "title": "Custom Guards", "breadcrumb": "Requests > Request Guards > Custom Guards", "anchor": "#custom-guards", "id": "requests#custom-guards"}, {"body": "When a request guard type can only be created through its FromRequest implementation, and the type is not Copy, the existence of a request guard value provides a type-level proof that the current request has been validated against an arbitrary policy. This provides powerful means of protecting your application against access-control violations by requiring data accessing methods to witness a proof of authorization via a request guard. We call the notion of using a request guard as a witness guard transparency.  As a concrete example, the following application has a function, health_records, that returns all of the health records in a database. Because health records are sensitive information, they should only be accessible by super users. The SuperUser request guard authenticates and authorizes a super user, and its FromRequest implementation is the only means by which a SuperUser can be constructed. By declaring the health_records function as follows, access control violations against health records are guaranteed to be prevented at compile-time:  The reasoning is as follows:  The health_records function requires an &SuperUser type.  The only constructor for a SuperUser type is FromRequest.  Only Rocket can provide an active &Request to construct via FromRequest.  Thus, there must be a Request authorizing a SuperUser to call  health_records.  ! note  At the expense of a lifetime parameter in the guard type, guarantees can be   made even stronger by tying the lifetime of the Request passed to   FromRequest to the request guard, ensuring that the guard value always   corresponds to an active request.  We recommend leveraging request guard transparency for all data accesses.", "title": "Guard Transparency", "breadcrumb": "Requests > Request Guards > Guard Transparency", "anchor": "#guard-transparency", "id": "requests#guard-transparency"}, {"body": "Request guards and forwarding are a powerful combination for enforcing policies. To illustrate, we consider how a simple authorization system might be implemented using these mechanisms.  We start with two request guards:  User: A regular, authenticated user.  The FromRequest implementation for User checks that a cookie identifies a user and returns a User value if so. If no user can be authenticated, the guard forwards.  AdminUser: A user authenticated as an administrator.  The FromRequest implementation for AdminUser checks that a cookie identifies an administrative user and returns an AdminUser value if so. If no user can be authenticated, the guard forwards.  We now use these two guards in combination with forwarding to implement the following three routes, each leading to an administrative control panel at /admin:  The three routes above encode authentication and authorization. The admin_panel route only succeeds if an administrator is logged in. Only then is the admin panel displayed. If the user is not an admin, the AdminUser guard will forward. Since the admin_panel_user route is ranked next highest, it is attempted next. This route succeeds if there is any user signed in, and an authorization failure message is displayed. Finally, if a user isn't signed in, the admin_panel_redirect route is attempted. Since this route has no guards, it always succeeds. The user is redirected to a log in page.", "title": "Forwarding Guards", "breadcrumb": "Requests > Request Guards > Forwarding Guards", "anchor": "#forwarding-guards", "id": "requests#forwarding-guards"}, {"body": "Cookies is an important, built-in request guard: it allows you to get, set, and remove cookies. Because Cookies is a request guard, an argument of its type can simply be added to a handler:  This results in the incoming request's cookies being accessible from the handler. The example above retrieves a cookie named message. Cookies can also be set and removed using the Cookies guard. The cookies example on GitHub illustrates further use of the Cookies type to get and set cookies, while the Cookies documentation contains complete usage information.", "title": "Cookies", "breadcrumb": "Requests > Cookies", "anchor": "#cookies", "id": "requests#cookies"}, {"body": "Cookies added via the Cookies::add() method are set in the clear. In other words, the value set is visible by the client. For sensitive data, Rocket provides private cookies.  Private cookies are just like regular cookies except that they are encrypted using authenticated encryption, a form of encryption which simultaneously provides confidentiality, integrity, and authenticity. This means that private cookies cannot be inspected, tampered with, or manufactured by clients. If you prefer, you can think of private cookies as being signed and encrypted.  The API for retrieving, adding, and removing private cookies is identical except methods are suffixed with _private. These methods are: get_private, add_private, and remove_private. An example of their usage is below:  Support for private cookies, which depends on the ring library, can be omitted at build time by disabling Rocket's default features, in-turn disabling the default private-cookies feature. To do so, modify your Cargo.toml file so that you depend on rocket as follows:", "title": "Private Cookies", "breadcrumb": "Requests > Cookies > Private Cookies", "anchor": "#private-cookies", "id": "requests#private-cookies"}, {"body": "To encrypt private cookies, Rocket uses the 256-bit key specified in the secret_key configuration parameter. If one is not specified, Rocket will automatically generate a fresh key. Note, however, that a private cookie can only be decrypted with the same key with which it was encrypted. As such, it is important to set a secret_key configuration parameter when using private cookies so that cookies decrypt properly after an application restart. Rocket emits a warning if an application is run in production without a configured secret_key.  Generating a string suitable for use as a secret_key configuration value is usually done through tools like openssl. Using openssl, a 256-bit base64 key can be generated with the command openssl rand -base64 32.  For more information on configuration, see the Configuration section of the guide.", "title": "Secret Key", "breadcrumb": "Requests > Cookies > Secret Key", "anchor": "#secret-key", "id": "requests#secret-key"}, {"body": "For safety reasons, Rocket currently requires that at most one Cookies instance be active at a time. It's uncommon to run into this restriction, but it can be confusing to handle if it does crop up.  If this does happen, Rocket will emit messages to the console that look as follows:  The messages will be emitted when a violating handler is called. The issue can be resolved by ensuring that two instances of Cookies cannot be active at once due to the offending handler. A common error is to have a handler that uses a Cookies request guard as well as a Custom request guard that retrieves Cookies, as so:  Because the cookies guard will fire before the custom guard, the custom guard will retrieve an instance of Cookies when one already exists for cookies. This scenario can be fixed by simply swapping the order of the guards:", "title": "One-At-A-Time", "breadcrumb": "Requests > Cookies > One-At-A-Time", "anchor": "#one-at-a-time", "id": "requests#one-at-a-time"}, {"body": "A route can specify the data format it is willing to accept or respond with by using the format route parameter. The value of the parameter is a string identifying an HTTP media type or a shorthand variant. For instance, for JSON data, the string application/json or simply json can be used.  When a route indicates a payload-supporting method (PUT, POST, DELETE, and PATCH), the format route parameter instructs Rocket to check against the Content-Type header of the incoming request. Only requests where the Content-Type header matches the format parameter will match to the route.  As an example, consider the following route:  The format parameter in the post attribute declares that only incoming requests with Content-Type: application/json will match new_user. (The data parameter is described in the next section.) Shorthand is also supported for the most common format arguments. Instead of using the full Content-Type, format = \"application/json\", you can also write shorthands like format = \"json\". For a full list of available shorthands, see the ContentType::parse_flexible() documentation.  When a route indicates a non-payload-supporting method (HEAD, OPTIONS, and, these purposes, GET) the format route parameter instructs Rocket to check against the Accept header of the incoming request. Only requests where the preferred media type in the Accept header matches the format parameter will match to the route.  As an example, consider the following route:  The format parameter in the get attribute declares that only incoming requests with application/json as the preferred media type in the Accept header will match user. If instead the route had been declared as post, Rocket would match the format against the Content-Type header of the incoming response.", "title": "Format", "breadcrumb": "Requests > Format", "anchor": "#format", "id": "requests#format"}, {"body": "Body data processing, like much of Rocket, is type directed. To indicate that a handler expects body data, annotate it with data = \"<param>\", where param is an argument in the handler. The argument's type must implement the FromData trait. It looks like this, where T is assumed to implement FromData:  Any type that implements FromData is also known as data guard.", "title": "Body Data", "breadcrumb": "Requests > Body Data", "anchor": "#body-data", "id": "requests#body-data"}, {"body": "Forms are one of the most common types of data handled in web applications, and Rocket makes handling them easy. Say your application is processing a form submission for a new todo Task. The form contains two fields: complete, a checkbox, and description, a text field. You can easily handle the form request in Rocket as follows:  The Form type implements the FromData trait as long as its generic parameter implements the FromForm trait. In the example, we've derived the FromForm trait automatically for the Task structure. FromForm can be derived for any structure whose fields implement FromFormValue. If a POST /todo request arrives, the form data will automatically be parsed into the Task structure. If the data that arrives isn't of the correct Content-Type, the request is forwarded. If the data doesn't parse or is simply invalid, a customizable 400 - Bad Request or 422 - Unprocessable Entity error is returned. As before, a forward or failure can be caught by using the Option and Result types:", "title": "Forms", "breadcrumb": "Requests > Body Data > Forms", "anchor": "#forms", "id": "requests#forms"}, {"body": "Rocket's FromForm parsing is strict by default. In other words, A Form<T> will parse successfully from an incoming form only if the form contains the exact set of fields in T. Said another way, a Form<T> will error on missing and/or extra fields. For instance, if an incoming form contains the fields \"a\", \"b\", and \"c\" while T only contains \"a\" and \"c\", the form will not parse as Form<T>.  Rocket allows you to opt-out of this behavior via the LenientForm data type. A LenientForm<T> will parse successfully from an incoming form as long as the form contains a superset of the fields in T. Said another way, a LenientForm<T> automatically discards extra fields without error. For instance, if an incoming form contains the fields \"a\", \"b\", and \"c\" while T only contains \"a\" and \"c\", the form will parse as LenientForm<T>.  You can use a LenientForm anywhere you'd use a Form. Its generic parameter is also required to implement FromForm. For instance, we can simply replace Form with LenientForm above to get lenient parsing:", "title": "Lenient Parsing", "breadcrumb": "Requests > Body Data > Forms > Lenient Parsing", "anchor": "#lenient-parsing", "id": "requests#lenient-parsing"}, {"body": "By default, Rocket matches the name of an incoming form field to the name of a structure field. While this behavior is typical, it may also be desired to use different names for form fields and struct fields while still parsing as expected. You can ask Rocket to look for a different form field for a given structure field by using the #[form(field = \"name\")] field annotation.  As an example, say that you're writing an application that receives data from an external service. The external service POSTs a form with a field named type. Since type is a reserved keyword in Rust, it cannot be used as the name of a field. To get around this, you can use field renaming as follows:  Rocket will then match the form field named type to the structure field named api_type automatically.", "title": "Field Renaming", "breadcrumb": "Requests > Body Data > Forms > Field Renaming", "anchor": "#field-renaming", "id": "requests#field-renaming"}, {"body": "Fields of forms can be easily validated via implementations of the FromFormValue trait. For example, if you'd like to verify that some user is over some age in a form, then you might define a new AdultAge type, use it as a field in a form structure, and implement FromFormValue so that it only validates integers over that age:  If a form is submitted with a bad age, Rocket won't call a handler requiring a valid form for that structure. You can use Option or Result types for fields to catch parse failures:  The FromFormValue trait can also be derived for enums with nullary fields:  The derive generates an implementation of the FromFormValue trait for the decorated enum. The implementation returns successfully when the form value matches, case insensitively, the stringified version of a variant's name, returning an instance of said variant.  The form validation and form kitchen sink examples provide further illustrations.", "title": "Field Validation", "breadcrumb": "Requests > Body Data > Forms > Field Validation", "anchor": "#field-validation", "id": "requests#field-validation"}, {"body": "Handling JSON data is no harder: simply use the Json type from rocket_contrib:  The only condition is that the generic type in Json implements the Deserialize trait from Serde. See the JSON example on GitHub for a complete example.", "title": "JSON", "breadcrumb": "Requests > Body Data > JSON", "anchor": "#json", "id": "requests#json"}, {"body": "Sometimes you just want to handle incoming data directly. For example, you might want to stream the incoming data out to a file. Rocket makes this as simple as possible via the Data type:  The route above accepts any POST request to the /upload path with Content-Type: text/plain  The incoming data is streamed out to tmp/upload.txt, and the number of bytes written is returned as a plain text response if the upload succeeds. If the upload fails, an error response is returned. The handler above is complete. It really is that simple! See the GitHub example code for the full crate.  ! warning: You should always set limits when reading incoming data.  To prevent DoS attacks, you should limit the amount of data you're willing to   accept. The take() reader adapter makes doing this easy:   data.open().take(LIMIT).", "title": "Streaming", "breadcrumb": "Requests > Body Data > Streaming", "anchor": "#streaming", "id": "requests#streaming"}, {"body": "Routing may fail for a variety of reasons. These include:  A guard fails.  A handler returns a Responder that fails.  No routes matched.  If any of these conditions occur, Rocket returns an error to the client. To do so, Rocket invokes the catcher corresponding to the error's status code. A catcher is like a route, except it only handles errors. Rocket provides default catchers for all of the standard HTTP error codes. To override a default catcher, or declare a catcher for a custom status code, use the catch attribute, which takes a single integer corresponding to the HTTP status code to catch. For instance, to declare a catcher for 404 Not Found errors, you'd write:  As with routes, the return type (here T) must implement Responder. A concrete implementation may look like:  Also as with routes, Rocket needs to know about a catcher before it is used to handle errors. The process, known as \"registering\" a catcher, is similar to mounting a route: call the register() method with a list of catchers via the catchers! macro. The invocation to add the 404 catcher declared above looks like:  Unlike route request handlers, catchers take exactly zero or one parameter. If the catcher takes a parameter, it must be of type &Request The error catcher example on GitHub illustrates their use in full.", "title": "Error Catchers", "breadcrumb": "Requests > Error Catchers", "anchor": "#error-catchers", "id": "requests#error-catchers"}, {"body": "You may have noticed that the return type of a handler appears to be arbitrary, and that's because it is! A value of any type that implements the Responder trait can be returned, including your own. In this section, we describe the Responder trait as well as several useful Responders provided by Rocket. We'll also briefly discuss how to implement your own Responder.", "title": "Responses", "breadcrumb": "Responses", "anchor": "#responses", "id": "responses#responses"}, {"body": "Types that implement Responder know how to generate a Response from their values. A Response includes an HTTP status, headers, and body. The body may either be fixed-sized or streaming. The given Responder implementation decides which to use. For instance, String uses a fixed-sized body, while File uses a streamed response. Responders may dynamically adjust their responses according to the incoming Request they are responding to.", "title": "Responder", "breadcrumb": "Responses > Responder", "anchor": "#responder", "id": "responses#responder"}, {"body": "Before we describe a few responders, we note that it is typical for responders to wrap other responders. That is, responders can be of the following form, where R is some type that implements Responder:  A wrapping responder modifies the response returned by R before responding with that same response. For instance, Rocket provides Responders in the status module that override the status code of the wrapped Responder. As an example, the Accepted type sets the status to 202 - Accepted. It can be used as follows:  Similarly, the types in the content module can be used to override the Content-Type of a response. For instance, to set the Content-Type of &'static str to JSON, you can use the content::Json type as follows:  ! warning: This is not the same as the Json in rocket_contrib!", "title": "Wrapping", "breadcrumb": "Responses > Responder > Wrapping", "anchor": "#wrapping", "id": "responses#wrapping"}, {"body": "Responders may fail; they need not always generate a response. Instead, they can return an Err with a given status code. When this happens, Rocket forwards the request to the error catcher for the given status code.  If an error catcher has been registered for the given status code, Rocket will invoke it. The catcher creates and returns a response to the client. If no error catcher has been registered and the error status code is one of the standard HTTP status code, a default error catcher will be used. Default error catchers return an HTML page with the status code and description. If there is no catcher for a custom status code, Rocket uses the 500 error catcher to return a response.", "title": "Errors", "breadcrumb": "Responses > Responder > Errors", "anchor": "#errors", "id": "responses#errors"}, {"body": "While not encouraged, you can also forward a request to a catcher manually by returning a Status directly. For instance, to forward to the catcher for 406: Not Acceptable, you would write:  The response generated by Status depends on the status code itself. As indicated above, for error status codes (in range [400, 599]), Status forwards to the corresponding error catcher. The table below summarizes responses generated by Status for these and other codes:", "title": "Status", "breadcrumb": "Responses > Responder > Status", "anchor": "#status", "id": "responses#status"}, {"body": "The Responder trait documentation details how to implement your own custom responders by explicitly implementing the trait. For most use cases, however, Rocket makes it possible to automatically derive an implementation of Responder. In particular, if your custom responder wraps an existing responder, headers, or sets a custom status or content-type, Responder can be automatically derived:  For the example above, Rocket generates a Responder implementation that:  Set the response's status to 500: Internal Server Error.  Sets the Content-Type to application/json.  Adds the headers self.header and self.more to the response.  Completes the response using self.inner.  Note that the first field is used as the inner responder while all remaining fields (unless ignored with #[response(ignore)]) are added as headers to the response. The optional #[response] attribute can be used to customize the status and content-type of the response. Because ContentType and Status are themselves headers, you can also dynamically set the content-type and status by simply including fields of these types.  For more on using the Responder derive, see the Responder derive documentation.", "title": "Custom Responders", "breadcrumb": "Responses > Custom Responders", "anchor": "#custom-responders", "id": "responses#custom-responders"}, {"body": "Rocket implements Responder for many types in Rust's standard library including String, &str, File, Option, and Result. The Responder documentation describes these in detail, but we briefly cover a few here.", "title": "Implementations", "breadcrumb": "Responses > Implementations", "anchor": "#implementations", "id": "responses#implementations"}, {"body": "The Responder implementations for &str and String are straight-forward: the string is used as a sized body, and the Content-Type of the response is set to text/plain. To get a taste for what such a Responder implementation looks like, here's the implementation for String:  Because of these implementations, you can directly return an &str or String type from a handler:", "title": "Strings", "breadcrumb": "Responses > Implementations > Strings", "anchor": "#strings", "id": "responses#strings"}, {"body": "Option is a wrapping responder: an Option<T> can only be returned when T implements Responder. If the Option is Some, the wrapped responder is used to respond to the client. Otherwise, a error of 404 - Not Found is returned to the client.  This implementation makes Option a convenient type to return when it is not known until process-time whether content exists. For example, because of Option, we can implement a file server that returns a 200 when a file is found and a 404 when a file is not found in just 4, idiomatic lines:", "title": "Option", "breadcrumb": "Responses > Implementations > Option", "anchor": "#option", "id": "responses#option"}, {"body": "Result is a special kind of wrapping responder: its functionality depends on whether the error type E implements Responder.  When the error type E implements Responder, the wrapped Responder in Ok or Err, whichever it might be, is used to respond to the client. This means that the responder can be chosen dynamically at run-time, and two different kinds of responses can be used depending on the circumstances. Revisiting our file server, for instance, we might wish to provide more feedback to the user when a file isn't found. We might do this as follows:  If the error type E does not implement Responder, then the error is simply logged to the console, using its Debug implementation, and a 500 error is returned to the client.", "title": "Result", "breadcrumb": "Responses > Implementations > Result", "anchor": "#result", "id": "responses#result"}, {"body": "Some of Rocket's best features are implemented through responders. You can find many of these responders in the response module and rocket_contrib library. Among these are:  Content - Used to override the Content-Type of a response.  NamedFile - Streams a file to the client; automatically sets the Content-Type based on the file's extension.  Redirect - Redirects the client to a different URI.  Stream - Streams a response to a client from an arbitrary Reader type.  status - Contains types that override the status code of a response.  Flash - Sets a \"flash\" cookie that is removed when accessed.  Json - Automatically serializes values into JSON.  MsgPack - Automatically serializes values into MessagePack.  Template - Renders a dynamic template using handlebars or Tera.", "title": "Rocket Responders", "breadcrumb": "Responses > Rocket Responders", "anchor": "#rocket-responders", "id": "responses#rocket-responders"}, {"body": "The Stream type deserves special attention. When a large amount of data needs to be sent to the client, it is better to stream the data to the client to avoid consuming large amounts of memory. Rocket provides the Stream type, making this easy. The Stream type can be created from any Read type. For example, to stream from a local Unix stream, we might write:", "title": "Streaming", "breadcrumb": "Responses > Rocket Responders > Streaming", "anchor": "#streaming", "id": "responses#streaming"}, {"body": "The Json responder in rocket_contrib allows you to easily respond with well-formed JSON data: simply return a value of type Json<T> where T is the type of a structure to serialize into JSON. The type T must implement the Serialize trait from serde, which can be automatically derived.  As an example, to respond with the JSON value of a Task structure, we might write:  The Json type serializes the structure into JSON, sets the Content-Type to JSON, and emits the serialized data in a fixed-sized body. If serialization fails, a 500 - Internal Server Error is returned.  The JSON example on GitHub provides further illustration.", "title": "JSON", "breadcrumb": "Responses > Rocket Responders > JSON", "anchor": "#json", "id": "responses#json"}, {"body": "Rocket includes built-in templating support that works largely through a Template responder in rocket_contrib. To render a template named \"index\", for instance, you might return a value of type Template as follows:  Templates are rendered with the render method. The method takes in the name of a template and a context to render the template with. The context can be any type that implements Serialize and serializes into an Object value, such as structs, HashMaps, and others.  For a template to be renderable, it must first be registered. The Template fairing automatically registers all discoverable templates when attached. The Fairings sections of the guide provides more information on fairings. To attach the template fairing, simply call .attach(Template::fairing()) on an instance of Rocket as follows:  Rocket discovers templates in the configurable template_dir directory. Templating support in Rocket is engine agnostic. The engine used to render a template depends on the template file's extension. For example, if a file ends with .hbs, Handlebars is used, while if a file ends with .tera, Tera is used.  ! note: The name of the template does not include its extension.  For a template file named index.html.tera, call render(\"index\") and use   the name \"index\" in templates, i.e, {% extends \"index\" %} or {% extends   \"base\" %} for base.html.tera.", "title": "Templates", "breadcrumb": "Responses > Templates", "anchor": "#templates", "id": "responses#templates"}, {"body": "When your application is compiled in debug mode (without the --release flag passed to cargo), templates are automatically reloaded when they are modified on supported platforms. This means that you don't need to rebuild your application to observe template changes: simply refresh! In release builds, reloading is disabled.  The Template API documentation contains more information about templates, including how to customize a template engine to add custom helpers and filters. The Handlebars templates example is a fully composed application that makes use of Handlebars templates, while the Tera templates example does the same for Tera.", "title": "Live Reloading", "breadcrumb": "Responses > Templates > Live Reloading", "anchor": "#live-reloading", "id": "responses#live-reloading"}, {"body": "Rocket's uri! macro allows you to build URIs to routes in your application in a robust, type-safe, and URI-safe manner. Type or route parameter mismatches are caught at compile-time, and changes to route URIs are automatically reflected in the generated URIs.  The uri! macro returns an Origin structure with the URI of the supplied route interpolated with the given values. Each value passed into uri! is rendered in its appropriate place in the URI using the UriDisplay implementation for the value's type. The UriDisplay implementation ensures that the rendered value is URI-safe.  Note that Origin implements Into<Uri> (and by extension, TryInto<Uri>), so it can be converted into a Uri using .into() as needed and passed into methods such as Redirect::to().  For example, given the following route:  URIs to person can be created as follows:  Rocket informs you of any mismatched parameters at compile-time:  Rocket also informs you of any type errors at compile-time:  We recommend that you use uri! exclusively when constructing URIs to your routes.", "title": "Typed URIs", "breadcrumb": "Responses > Typed URIs", "anchor": "#typed-uris", "id": "responses#typed-uris"}, {"body": "As illustrated in the previous above, query parameters can be ignored using _ in place of an expression in a uri! invocation. The corresponding type in the route URI must implement Ignorable. Ignored parameters are not interpolated into the resulting Origin. Path parameters are not ignorable.", "title": "Ignorables", "breadcrumb": "Responses > Typed URIs > Ignorables", "anchor": "#ignorables", "id": "responses#ignorables"}, {"body": "The UriDisplay trait can be derived for custom types. For types that appear in the path part of a URI, derive using UriDisplayPath; for types that appear in the query part of a URI, derive using UriDisplayQuery.  As an example, consider the following form structure and route:  By deriving using UriDisplayQuery, an implementation of UriDisplay<Query> is automatically generated, allowing for URIs to add_user to be generated using uri!:", "title": "Deriving UriDisplay", "breadcrumb": "Responses > Typed URIs > Deriving UriDisplay", "anchor": "#deriving-uridisplay", "id": "responses#deriving-uridisplay"}, {"body": "The UriPart trait categorizes types that mark a part of the URI as either a Path or a Query. Said another way, types that implement UriPart are marker types that represent a part of a URI at the type-level. Traits such as UriDisplay and FromUriParam bound a generic parameter by UriPart: P: UriPart. This creates two instances of each trait: UriDisplay<Query> and UriDisplay<Path>, and FromUriParam<Query> and FromUriParam<Path>.  As the names might imply, the Path version of the traits is used when displaying parameters in the path part of the URI while the Query version is used when displaying parameters in the query part of the URI. These distinct versions of the traits exist exactly to differentiate, at the type-level, where in the URI a value is to be written to, allowing for type safety in the face of differences between the two locations. For example, while it is valid to use a value of None in the query part, omitting the parameter entirely, doing so is not valid in the path part. By differentiating in the type system, both of these conditions can be enforced appropriately through distinct implementations of FromUriParam<Path> and FromUriParam<Query>.", "title": "Typed URI Parts", "breadcrumb": "Responses > Typed URIs > Typed URI Parts", "anchor": "#typed-uri-parts", "id": "responses#typed-uri-parts"}, {"body": "The FromUriParam is used to perform a conversion for each value passed to uri! before it is displayed with UriDisplay. If a FromUriParam<P, S> implementation exists for a type T for part URI part P, then a value of type S can be used in uri! macro for a route URI parameter declared with a type of T in part P. For example, the following implementation, provided by Rocket, allows an &str to be used in a uri! invocation for route URI parameters declared as String:  Other conversions to be aware of are:  &str to RawStr  String to &str  String to RawStr  T to Option<T>  T to Result<T, E>  T to Form<T>  &str to &Path  &str to PathBuf  Conversions nest. For instance, a value of type T can be supplied when a value of type Option<Form<T>> is expected:  See the FromUriParam documentation for further details.", "title": "Conversions", "breadcrumb": "Responses > Typed URIs > Conversions", "anchor": "#conversions", "id": "responses#conversions"}, {"body": "Many web applications have a need to maintain state. This can be as simple as maintaining a counter for the number of visits or as complex as needing to access job queues and multiple databases. Rocket provides the tools to enable these kinds of interactions in a safe and simple manner.", "title": "State", "breadcrumb": "State", "anchor": "#state", "id": "state#state"}, {"body": "The enabling feature for maintaining state is managed state. Managed state, as the name implies, is state that Rocket manages for your application. The state is managed on a per-type basis: Rocket will manage at most one value of a given type.  The process for using managed state is simple:  Call manage on the Rocket instance corresponding to your application  with the initial value of the state.  Add a State<T> type to any request handler, where T is the type of the  value passed into manage.  ! note: All managed state must be thread-safe.  Because Rocket automatically multithreads your application, handlers can   concurrently access managed state. As a result, managed state must be   thread-safe. Thanks to Rust, this condition is checked at compile-time by   ensuring that the type of values you store in managed state implement Send +   Sync.", "title": "Managed State", "breadcrumb": "State > Managed State", "anchor": "#managed-state", "id": "state#managed-state"}, {"body": "To instruct Rocket to manage state for your application, call the manage method on an instance of Rocket. For example, to ask Rocket to manage a HitCount structure with an internal AtomicUsize with an initial value of 0, we can write the following:  The manage method can be called any number of times as long as each call refers to a value of a different type. For instance, to have Rocket manage both a HitCount value and a Config value, we can write:", "title": "Adding State", "breadcrumb": "State > Managed State > Adding State", "anchor": "#adding-state", "id": "state#adding-state"}, {"body": "State that is being managed by Rocket can be retrieved via the State type: a request guard for managed state. To use the request guard, add a State<T> type to any request handler, where T is the type of the managed state. For example, we can retrieve and respond with the current HitCount in a count route as follows:  You can retrieve more than one State type in a single route as well:  ! warning  If you request a State<T> for a T that is not managed, Rocket won't call   the offending route. Instead, Rocket will log an error message and return a   500 error to the client.  You can find a complete example using the HitCount structure in the state example on GitHub and learn more about the manage method and State type in the API docs.", "title": "Retrieving State", "breadcrumb": "State > Managed State > Retrieving State", "anchor": "#retrieving-state", "id": "state#retrieving-state"}, {"body": "It can also be useful to retrieve managed state from a FromRequest implementation. To do so, simply invoke State<T> as a guard using the Request::guard() method.", "title": "Within Guards", "breadcrumb": "State > Managed State > Within Guards", "anchor": "#within-guards", "id": "state#within-guards"}, {"body": "While managed state is global and available application-wide, request-local state is local to a given request, carried along with the request, and dropped once the request is completed. Request-local state can be used whenever a Request is available, such as in a fairing, a request guard, or a responder.  Request-local state is cached: if data of a given type has already been stored, it will be reused. This is especially useful for request guards that might be invoked multiple times during routing and processing of a single request, such as those that deal with authentication.  As an example, consider the following request guard implementation for RequestId that uses request-local state to generate and expose a unique integer ID per request:  Note that, without request-local state, it would not be possible to:  Associate a piece of data, here an ID, directly with a request.  Ensure that a value is generated at most once per request.  For more examples, see the FromRequest request-local state documentation, which uses request-local state to cache expensive authentication and authorization computations, and the Fairing documentation, which uses request-local state to implement request timing.", "title": "Request-Local State", "breadcrumb": "State > Request-Local State", "anchor": "#request-local-state", "id": "state#request-local-state"}, {"body": "Rocket includes built-in, ORM-agnostic support for databases. In particular, Rocket provides a procedural macro that allows you to easily connect your Rocket application to databases through connection pools. A database connection pool is a data structure that maintains active database connections for later use in the application. This implementation of connection pooling support is based on r2d2 and exposes connections through request guards. Databases are individually configured through Rocket's regular configuration mechanisms: a Rocket.toml file, environment variables, or procedurally.  Connecting your Rocket application to a database using this library occurs in three simple steps:  Configure the databases in Rocket.toml.  Associate a request guard type and fairing with each database.  Use the request guard to retrieve a connection in a handler.  Presently, Rocket provides built-in support for the following databases:  | Kind     | Driver                | Version   | Poolable Type                | Feature                | |----------|-----------------------|-----------|--------------------------------|------------------------| | MySQL    | Diesel              | 1       | diesel::MysqlConnection    | diesel_mysql_pool    | | MySQL    | rust-mysql-simple | 16      | mysql::conn                | mysql_pool           | | Postgres | Diesel              | 1       | diesel::PgConnection       | diesel_postgres_pool | | Postgres | Rust-Postgres       | 0.15    | postgres::Connection       | postgres_pool        | | Sqlite   | Diesel              | 1       | diesel::SqliteConnection   | diesel_sqlite_pool   | | Sqlite   | Rustqlite         | 0.16    | rusqlite::Connection       | sqlite_pool          | | Neo4j    | rusted_cypher     | 1       | rusted_cypher::GraphClient | cypher_pool          | | Redis    | redis-rs          | 0.10    | redis::Connection          | redis_pool           | | MongoDB  | mongodb           | 0.3.12  | mongodb::db::Database      | mongodb_pool         | | Memcache | memcache          | 0.11    | memcache::Client           | memcache_pool        |", "title": "Databases", "breadcrumb": "State > Databases", "anchor": "#databases", "id": "state#databases"}, {"body": "To connect your Rocket application to a given database, first identify the \"Kind\" and \"Driver\" in the table that matches your environment. The feature corresponding to your database type must be enabled. This is the feature identified in the \"Feature\" column. For instance, for Diesel-based SQLite databases, you'd write in Cargo.toml:  Then, in Rocket.toml or the equivalent via environment variables, configure the URL for the database in the databases table:  In your application's source code, create a unit-like struct with one internal type. This type should be the type listed in the \"Poolable Type\" column. Then decorate the type with the #[database] attribute, providing the name of the database that you configured in the previous step as the only parameter. Finally, attach the fairing returned by YourType::fairing(), which was generated by the #[database] attribute:  That's it! Whenever a connection to the database is needed, use your type as a request guard:  If your application uses features of a database engine that are not available by default, for example support for chrono or uuid, you may enable those features by adding them in Cargo.toml like so:  For more on Rocket's built-in database support, see the rocket_contrib::databases module documentation.", "title": "Usage", "breadcrumb": "State > Databases > Usage", "anchor": "#usage", "id": "state#usage"}, {"body": "Fairings are Rocket's approach to structured middleware. With fairings, your application can hook into the request lifecycle to record or rewrite information about incoming requests and outgoing responses.", "title": "Fairings", "breadcrumb": "Fairings", "anchor": "#fairings", "id": "fairings#fairings"}, {"body": "Any type that implements the Fairing trait is a fairing. Fairings hook into Rocket's request lifecycle, receiving callbacks for events such as incoming requests and outgoing responses. Rocket passes information about these events to the fairing; the fairing can do what it wants with the information. This includes rewriting requests or responses, recording information about the event, or doing nothing at all.  Rocket\u2019s fairings are a lot like middleware from other frameworks, but they bear a few key distinctions:  Fairings cannot terminate or respond to an incoming request directly.  Fairings cannot inject arbitrary, non-request data into a request.  Fairings can prevent an application from launching.  Fairings can inspect and modify the application's configuration.  If you are familiar with middleware from other frameworks, you may find yourself reaching for fairings instinctively. Before doing so, remember that Rocket provides a rich set of mechanisms such as request guards and data guards that can be used to solve problems in a clean, composable, and robust manner.  ! warning  As a general rule of thumb, only globally applicable actions should be   effected through fairings. You should not use a fairing to implement   authentication or authorization (preferring to use a request guard instead)   unless the authentication or authorization applies to all or the   overwhelming majority application. On the other hand, you should use a   fairing to record timing and usage statistics or to enforce global security   policies.", "title": "Overview", "breadcrumb": "Fairings > Overview", "anchor": "#overview", "id": "fairings#overview"}, {"body": "Fairings are registered with Rocket via the attach method on a Rocket instance. Only when a fairing is attached will its callbacks fire. As an example, the following snippet attached two fairings,  req_fairing and res_fairing, to a new Rocket instance:  Fairings are executed in the order in which they are attached: the first attached fairing has its callbacks executed before all others. Because fairing callbacks may not be commutative, the order in which fairings are attached may be significant.", "title": "Attaching", "breadcrumb": "Fairings > Overview > Attaching", "anchor": "#attaching", "id": "fairings#attaching"}, {"body": "There are four events for which Rocket issues fairing callbacks. Each of these events is described below:  Attach (on_attach)  An attach callback is called when a fairing is first attached via the attach method. An attach callback can arbitrarily modify the Rocket instance being constructed and optionally abort launch. Attach fairings are commonly used to parse and validate configuration values, aborting on bad configurations, and inserting the parsed value into managed state for later retrieval.  Launch (on_launch)  A launch callback is called immediately before the Rocket application has launched. A launch callback can inspect the Rocket instance being launched. A launch callback can be a convenient hook for launching services related to the Rocket application being launched.  Request (on_request)  A request callback is called just after a request is received. A request callback can modify the request at will and peek into the incoming data. It may not, however, abort or respond directly to the request; these issues are better handled via request guards or via response callbacks.  Response (on_response)  A response callback is called when a response is ready to be sent to the client. A response callback can modify part or all of the response. As such, a response fairing can be used to provide a response when the greater application fails by rewriting 404 responses as desired. As another example, response fairings can also be used to inject headers into all outgoing responses.", "title": "Callbacks", "breadcrumb": "Fairings > Overview > Callbacks", "anchor": "#callbacks", "id": "fairings#callbacks"}, {"body": "Recall that a fairing is any type that implements the Fairing trait. A Fairing implementation has one required method: info, which returns an Info structure. This structure is used by Rocket to assign a name to the fairing and determine the set of callbacks the fairing is registering for. A Fairing can implement any of the available callbacks: on_attach, on_launch, on_request, and on_response. Each callback has a default implementation that does absolutely nothing.", "title": "Implementing", "breadcrumb": "Fairings > Implementing", "anchor": "#implementing", "id": "fairings#implementing"}, {"body": "A type implementing Fairing is required to be Send + Sync + 'static. This means that the fairing must be sendable across thread boundaries (Send), thread-safe (Sync), and have only static references, if any ('static). Note that these bounds do not prohibit a Fairing from holding state: the state need simply be thread-safe and statically available or heap allocated.", "title": "Requirements", "breadcrumb": "Fairings > Implementing > Requirements", "anchor": "#requirements", "id": "fairings#requirements"}, {"body": "Imagine that we want to record the number of GET and POST requests that our application has received. While we could do this with request guards and managed state, it would require us to annotate every GET and POST request with custom types, polluting handler signatures. Instead, we can create a simple fairing that acts globally.  The code for a Counter fairing below implements exactly this. The fairing receives a request callback, where it increments a counter on each GET and POST request. It also receives a response callback, where it responds to unrouted requests to the /counts path by returning the recorded number of counts.  For brevity, imports are not shown. The complete example can be found in the Fairing documentation.", "title": "Example", "breadcrumb": "Fairings > Implementing > Example", "anchor": "#example", "id": "fairings#example"}, {"body": "For simple occasions, implementing the Fairing trait can be cumbersome. This is why Rocket provides the AdHoc type, which creates a fairing from a simple function or closure. Using the AdHoc type is easy: simply call the on_attach, on_launch, on_request, or on_response constructors on AdHoc to create an AdHoc structure from a function or closure.  As an example, the code below creates a Rocket instance with two attached ad-hoc fairings. The first, a launch fairing named \"Launch Printer\", simply prints a message indicating that the application is about to launch. The second named \"Put Rewriter\", a request fairing, rewrites the method of all requests to be PUT.", "title": "Ad-Hoc Fairings", "breadcrumb": "Fairings > Ad-Hoc Fairings", "anchor": "#ad-hoc-fairings", "id": "fairings#ad-hoc-fairings"}, {"body": "Every application should be well tested and understandable. Rocket provides the tools to perform unit and integration tests. It also provides a means to inspect code generated by Rocket.", "title": "Testing", "breadcrumb": "Testing", "anchor": "#testing", "id": "testing#testing"}, {"body": "Rocket applications are tested by dispatching requests to a local instance of Rocket. The local module contains all of the structures necessary to do so. In particular, it contains a Client structure that is used to create LocalRequest structures that can be dispatched against a given Rocket instance. Usage is straightforward:  Construct a Rocket instance that represents the application.  Construct a Client using the Rocket instance.  Construct requests using the Client instance.  Dispatch the request to retrieve the response.", "title": "Local Dispatching", "breadcrumb": "Testing > Local Dispatching", "anchor": "#local-dispatching", "id": "testing#local-dispatching"}, {"body": "A dispatch of a LocalRequest returns a LocalResponse which can be used transparently as a Response value. During testing, the response is usually validated against expected properties. These includes things like the response HTTP status, the inclusion of headers, and expected body data.  The Response type provides methods to ease this sort of validation. We list a few below:  status: returns the HTTP status in the response.  content_type: returns the Content-Type header in the response.  headers: returns a map of all of the headers in the response.  body_string: returns the body data as a String.  body_bytes: returns the body data as a Vec<u8>.  These methods are typically used in combination with the assert_eq! or assert! macros as follows:", "title": "Validating Responses", "breadcrumb": "Testing > Validating Responses", "anchor": "#validating-responses", "id": "testing#validating-responses"}, {"body": "To solidify an intuition for how Rocket applications are tested, we walk through how to test the \"Hello, world!\" application below:  Notice that we've separated the creation of the Rocket instance from the launch of the instance. As you'll soon see, this makes testing our application easier, less verbose, and less error-prone.", "title": "Testing \"Hello, world!\"", "breadcrumb": "Testing > Testing \"Hello, world!\"", "anchor": "#testing-hello-world", "id": "testing#testing-hello-world"}, {"body": "First, we'll create a test module with the proper imports:  You can also move the body of the test module into its own file, say tests.rs, and then import the module into the main file using:", "title": "Setting Up", "breadcrumb": "Testing > Testing \"Hello, world!\" > Setting Up", "anchor": "#setting-up", "id": "testing#setting-up"}, {"body": "To test our \"Hello, world!\" application, we first create a Client for our Rocket instance. It's okay to use methods like expect and unwrap during testing: we want our tests to panic when something goes wrong.  Then, we create a new GET / request and dispatch it, getting back our application's response:  Finally, we ensure that the response contains the information we expect it to. Here, we want to ensure two things:  The status is 200 OK.  The body is the string \"Hello, world!\".  We do this by checking the Response object directly:  That's it! Altogether, this looks like:  The tests can be run with cargo test. You can find the full source code to this example on GitHub.", "title": "Testing", "breadcrumb": "Testing > Testing \"Hello, world!\" > Testing", "anchor": "#testing", "id": "testing#testing"}, {"body": "It can be useful to inspect the code that Rocket's code generation is emitting, especially when you get a strange type error. To have Rocket log the code that it is emitting to the console, set the ROCKET_CODEGEN_DEBUG environment variable when compiling:  During compilation, you should see output like:  This corresponds to the facade request handler Rocket has generated for the hello route.", "title": "Codegen Debug", "breadcrumb": "Testing > Codegen Debug", "anchor": "#codegen-debug", "id": "testing#codegen-debug"}, {"body": "Rocket aims to have a flexible and usable configuration system. Rocket applications can be configured via a configuration file, through environment variables, or both. Configurations are separated into three environments: development, staging, and production. The working environment is selected via an environment variable.", "title": "Configuration", "breadcrumb": "Configuration", "anchor": "#configuration", "id": "configuration#configuration"}, {"body": "At any point in time, a Rocket application is operating in a given configuration environment. There are three such environments:  development (short: dev)  staging (short: stage)  production (short: prod)  Without any action, Rocket applications run in the development environment for debug builds and the production environment for non-debug builds. The environment can be changed via the ROCKET_ENV environment variable. For example, to launch an application in the staging environment, we can run:  Note that you can use the short or long form of the environment name to specify the environment, stage or staging here. Rocket tells us the environment we have chosen and its configuration when it launches:", "title": "Environment", "breadcrumb": "Configuration > Environment", "anchor": "#environment", "id": "configuration#environment"}, {"body": "An optional Rocket.toml file can be used to specify the configuration parameters for each environment. If it is not present, the default configuration parameters are used. Rocket searches for the file starting at the current working directory. If it is not found there, Rocket checks the parent directory. Rocket continues checking parent directories until the root is reached.  The file must be a series of TOML tables, at most one for each environment, and an optional \"global\" table. Each table contains key-value pairs corresponding to configuration parameters for that environment. If a configuration parameter is missing, the default value is used. The following is a complete Rocket.toml file, where every standard configuration parameter is specified with the default value:  The workers and secret_key default parameters are computed by Rocket automatically; the values above are not valid TOML syntax. When manually specifying the number of workers, the value should be an integer: workers = 10. When manually specifying the secret key, the value should a 256-bit base64 encoded string. Such a string can be generated using a tool such as openssl: openssl rand -base64 32.  The \"global\" pseudo-environment can be used to set and/or override configuration parameters globally. A parameter defined in a [global] table sets, or overrides if already present, that parameter in every environment. For example, given the following Rocket.toml file, the value of address will be \"1.2.3.4\" in every environment:", "title": "Rocket.toml", "breadcrumb": "Configuration > Rocket.toml", "anchor": "#rockettoml", "id": "configuration#rockettoml"}, {"body": "The limits parameter configures the maximum amount of data Rocket will accept for a given data type. The parameter is a table where each key corresponds to a data type and each value corresponds to the maximum size in bytes Rocket should accept for that type.  By default, Rocket limits forms to 32KiB (32768 bytes). To increase the limit, simply set the limits.forms configuration parameter. For example, to increase the forms limit to 128KiB globally, we might write:  The limits parameter can contain keys and values that are not endemic to Rocket. For instance, the Json type reads the json limit value to cap incoming JSON data. You should use the limits parameter for your application's data limits as well. Data limits can be retrieved at runtime via the Request::limits() method.", "title": "Data Limits", "breadcrumb": "Configuration > Data Limits", "anchor": "#data-limits", "id": "configuration#data-limits"}, {"body": "In addition to overriding default configuration parameters, a configuration file can also define values for any number of extra configuration parameters. While these parameters aren't used by Rocket directly, other libraries, or your own application, can use them as they wish. As an example, the Template type accepts a value for the template_dir configuration parameter. The parameter can be set in Rocket.toml as follows:  This sets the template_dir extra configuration parameter to \"dev_templates/\" when operating in the development environment and \"prod_templates/\" when operating in the production environment. Rocket will prepend the [extra] tag to extra configuration parameters when launching:  To retrieve a custom, extra configuration parameter in your application, we recommend using an ad-hoc attach fairing in combination with managed state. For example, if your application makes use of a custom assets_dir parameter:  The following code will:  Read the configuration parameter in an ad-hoc attach fairing.  Store the parsed parameter in an AssertsDir structure in managed state.  Retrieve the parameter in an assets route via the State guard.", "title": "Extras", "breadcrumb": "Configuration > Extras", "anchor": "#extras", "id": "configuration#extras"}, {"body": "All configuration parameters, including extras, can be overridden through environment variables. To override the configuration parameter {param}, use an environment variable named ROCKET_{PARAM}. For instance, to override the \"port\" configuration parameter, you can run your application with:  Environment variables take precedence over all other configuration methods: if the variable is set, it will be used as the value for the parameter. Variable values are parsed as if they were TOML syntax. As illustration, consider the following examples:", "title": "Environment Variables", "breadcrumb": "Configuration > Environment Variables", "anchor": "#environment-variables", "id": "configuration#environment-variables"}, {"body": "In addition to using environment variables or a config file, Rocket can also be configured using the rocket::custom() method and ConfigBuilder:  Configuration via rocket::custom() replaces calls to rocket::ignite() and all configuration from Rocket.toml or environment variables. In other words, using rocket::custom() results in Rocket.toml and environment variables being ignored.", "title": "Programmatic", "breadcrumb": "Configuration > Programmatic", "anchor": "#programmatic", "id": "configuration#programmatic"}, {"body": "! warning: Rocket's built-in TLS is not considered ready for production use.   It is intended for development use only.  Rocket includes built-in, native support for TLS >= 1.2 (Transport Layer Security). In order for TLS support to be enabled, Rocket must be compiled with the \"tls\" feature. To do this, add the \"tls\" feature to the rocket dependency in your Cargo.toml file:  TLS is configured through the tls configuration parameter. The value of tls must be a table with two keys:  certs: [string] a path to a certificate chain in PEM format  key: [string] a path to a private key file in PEM format for the certificate in certs  The recommended way to specify these parameters is via the global environment:  Of course, you can always specify the configuration values per environment:  Or via environment variables:", "title": "Configuring TLS", "breadcrumb": "Configuration > Configuring TLS", "anchor": "#configuring-tls", "id": "configuration#configuring-tls"}, {"body": "To give you a taste of what a real Rocket application looks like, this section of the guide is a tutorial on how to create a Pastebin application in Rocket. A pastebin is a simple web application that allows users to upload a text document and later retrieve it via a special URL. They're often used to share code snippets, configuration files, and error logs. In this tutorial, we'll build a simple pastebin service that allows users to upload a file from their terminal. The service will respond back with a URL to the uploaded file.", "title": "Pastebin", "breadcrumb": "Pastebin", "anchor": "#pastebin", "id": "pastebin#pastebin"}, {"body": "A souped-up, completed version of the application you're about to build is deployed live at paste.rs. Feel free to play with the application to get a feel for how it works. For example, to upload a text document named test.txt, you can do:  The finished product is composed of the following routes:  index: GET / - returns a simple HTML page with instructions about how to use the service  upload: POST / - accepts raw data in the body of the request and responds with a URL of a page containing the body's content  retrieve: GET /<id> - retrieves the content for the paste with id <id>", "title": "Finished Product", "breadcrumb": "Pastebin > Finished Product", "anchor": "#finished-product", "id": "pastebin#finished-product"}, {"body": "Let's get started! First, create a fresh Cargo binary project named rocket-pastebin:  Then add the usual Rocket dependencies to the Cargo.toml file:  And finally, create a skeleton Rocket application to work off of in src/main.rs:  Ensure everything works by running the application:  At this point, we haven't declared any routes or handlers, so visiting any page will result in Rocket returning a 404 error. Throughout the rest of the tutorial, we'll create the three routes and accompanying handlers.", "title": "Getting Started", "breadcrumb": "Pastebin > Getting Started", "anchor": "#getting-started", "id": "pastebin#getting-started"}, {"body": "The first route we'll create is the index route. This is the page users will see when they first visit the service. As such, the route should field requests of the form GET /. We declare the route and its handler by adding the index function below to src/main.rs:  This declares the index route for requests to GET / as returning a static string with the specified contents. Rocket will take the string and return it as the body of a fully formed HTTP response with Content-Type: text/plain. You can read more about how Rocket formulates responses at the API documentation for the Responder   trait.  Remember that routes first need to be mounted before Rocket dispatches requests to them. To mount the index route, modify the main function so that it reads:  You should now be able to cargo run the application and visit the root path (/) to see the text being displayed.", "title": "Index", "breadcrumb": "Pastebin > Index", "anchor": "#index", "id": "pastebin#index"}, {"body": "The most complicated aspect of the pastebin, as you might imagine, is handling upload requests. When a user attempts to upload a pastebin, our service needs to generate a unique ID for the upload, read the data, write it out to a file or database, and then return a URL with the ID. We'll take each of these one step at a time, beginning with generating IDs.", "title": "Uploading", "breadcrumb": "Pastebin > Uploading", "anchor": "#uploading", "id": "pastebin#uploading"}, {"body": "Generating a unique and useful ID is an interesting topic, but it is outside the scope of this tutorial. Instead, we simply provide the code for a PasteID structure that represents a probably unique ID. Read through the code, then copy/paste it into a new file named paste_id.rs in the src/ directory:  Then, in src/main.rs, add the following after extern crate rocket:  Finally, add a dependency for the rand crate to the Cargo.toml file:  Then, ensure that your application builds with the new code:  You'll likely see many \"unused\" warnings for the new code we've added: that's okay and expected. We'll be using the new code soon.", "title": "Unique IDs", "breadcrumb": "Pastebin > Uploading > Unique IDs", "anchor": "#unique-ids", "id": "pastebin#unique-ids"}, {"body": "Believe it or not, the hard part is done! (whew!).  To process the upload, we'll need a place to store the uploaded files. To simplify things, we'll store the uploads in a directory named upload/. Create an upload directory next to the src directory:  For the upload route, we'll need to use a few items:  The Data structure is key here: it represents an unopened stream to the incoming request body data. We'll use it to efficiently stream the incoming request to a file.", "title": "Processing", "breadcrumb": "Pastebin > Uploading > Processing", "anchor": "#processing", "id": "pastebin#processing"}, {"body": "We're finally ready to write the upload route. Before we show you the code, you should attempt to write the route yourself. Here's a hint: a possible route and handler signature look like this:  Your code should:  Create a new PasteID of a length of your choosing.  Construct a filename inside upload/ given the PasteID.  Stream the Data to the file with the constructed filename.  Construct a URL given the PasteID.  Return the URL to the client.  Here's our version (in src/main.rs):  Ensure that the route is mounted at the root path:  Test that your route works via cargo run. From a separate terminal, upload a file using curl. Then verify that the file was saved to the upload directory with the correct ID:  Note that since we haven't created a GET /<id> route, visiting the returned URL will result in a 404. We'll fix that now.", "title": "Upload Route", "breadcrumb": "Pastebin > Uploading > Upload Route", "anchor": "#upload-route", "id": "pastebin#upload-route"}, {"body": "The final step is to create the retrieve route which, given an <id>, will return the corresponding paste if it exists.  Here's a first take at implementing the retrieve route. The route below takes in an <id> as a dynamic path element. The handler uses the id to construct a path to the paste inside upload/, and then attempts to open the file at that path, optionally returning the File if it exists. Rocket treats a None Responder as a 404 error, which is exactly what we want to return when the requested paste doesn't exist.  Make sure that the route is mounted at the root path:  Unfortunately, there's a problem with this code. Can you spot the issue? The RawStr type should tip you off!  The issue is that the user controls the value of id, and as a result, can coerce the service into opening files inside upload/ that aren't meant to be opened. For instance, imagine that you later decide that a special file upload/_credentials.txt will store some important, private information. If the user issues a GET request to /_credentials.txt, the server will read and return the upload/_credentials.txt file, leaking the sensitive information. This is a big problem; it's known as the full path disclosure attack, and Rocket provides the tools to prevent this and other kinds of attacks from happening.  To prevent the attack, we need to validate id before we use it. Since the id is a dynamic parameter, we can use Rocket's FromParam trait to implement the validation and ensure that the id is a valid PasteID before using it. We do this by implementing FromParam for PasteID in src/paste_id.rs, as below:  Then, we simply need to change the type of id in the handler to PasteID. Rocket will then ensure that <id> represents a valid PasteID before calling the retrieve route, preventing attacks on the retrieve route:  Note that our valid_id function is simplistic and could be improved by, for example, checking that the length of the id is within some known bound or potentially blacklisting sensitive files as needed.  The wonderful thing about using FromParam and other Rocket traits is that they centralize policies. For instance, here, we've centralized the policy for valid PasteIDs in dynamic parameters. At any point in the future, if other routes are added that require a PasteID, no further work has to be done: simply use the type in the signature and Rocket takes care of the rest.", "title": "Retrieving Pastes", "breadcrumb": "Pastebin > Retrieving Pastes", "anchor": "#retrieving-pastes", "id": "pastebin#retrieving-pastes"}, {"body": "That's it! Ensure that all of your routes are mounted and test your application. You've now written a simple (~75 line!) pastebin in Rocket! There are many potential improvements to this small application, and we encourage you to work through some of them to get a better feel for Rocket. Here are some ideas:  Add a web form to the index where users can manually input new pastes. Accept the form at POST /. Use format and/or rank to specify which of the two POST / routes should be called.  Support deletion of pastes by adding a new DELETE /<id> route. Use PasteID to validate <id>.  Limit the upload to a maximum size. If the upload exceeds that size, return a 206 partial status code. Otherwise, return a 201 created status code.  Set the Content-Type of the return value in upload and retrieve to text/plain.  Return a unique \"key\" after each upload and require that the key is present and matches when doing deletion. Use one of Rocket's core traits to do the key validation.  Add a PUT /<id> route that allows a user with the key for <id> to replace the existing paste, if any.  Add a new route, GET /<id>/<lang> that syntax highlights the paste with ID <id> for language <lang>. If <lang> is not a known language, do no highlighting. Possibly validate <lang> with FromParam.  Use the local module to write unit tests for your pastebin.  Dispatch a thread before launching Rocket in main that periodically cleans up idling old pastes in upload/.  You can find the full source code for the completed pastebin tutorial on GitHub.", "title": "Conclusion", "breadcrumb": "Pastebin > Conclusion", "anchor": "#conclusion", "id": "pastebin#conclusion"}, {"body": "We hope you agree that Rocket is a refreshing take on web frameworks. As with any software project, Rocket is alive. There are always things to improve, and we're happy to take the best ideas. If you have something in mind, please submit an issue.", "title": "Conclusion", "breadcrumb": "Conclusion", "anchor": "#conclusion", "id": "conclusion#conclusion"}, {"body": "If you find yourself having trouble developing Rocket applications, you can get help via the #rocket IRC channel on the Mozilla IRC Server at irc.mozilla.org and the bridged Rocket room on Matrix. If you're not familiar with IRC, we recommend chatting through Matrix via Riot or via the Kiwi web IRC client. You can learn more about IRC via Mozilla's Getting Started with IRC guide.", "title": "Getting Help", "breadcrumb": "Conclusion > Getting Help", "anchor": "#getting-help", "id": "conclusion#getting-help"}, {"body": "The best way to learn Rocket is to build something. It should be fun and easy, and there's always someone to help. Alternatively, you can read through the Rocket examples or the Rocket source code. Whatever you decide to do next, we hope you have a blast!", "title": "What's next?", "breadcrumb": "Conclusion > What's next?", "anchor": "#whats-next", "id": "conclusion#whats-next"}]}